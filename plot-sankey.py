import csv
import argparse
import plotly.graph_objects as go

def save_sankey_diagram(fig, output_file):
    if output_file:
        if output_file.endswith(".html"):
            fig.write_html(output_file)
            print(f"Saved interactive HTML: {output_file}")
        elif output_file.endswith((".png", ".jpg", ".jpeg", ".pdf", ".svg")):
            fig.write_image(output_file)
            print(f"Saved image file: {output_file}")
        else:
            print("Unsupported file format. Use .html, .png, .jpg, .jpeg, .pdf, or .svg.")
    else:
        fig.show()  # Show the plot if no output file is specified

def process_csv(input_csv, csv_type):
    nodes = []  # List of unique taxonomy nodes
    node_map = {}  # Map taxonomic label to index
    links = []  # List of link connections with flow values
    hover_texts = []  # Custom hover text for percentages
    processed_lineages = set()  # Tracks added lineage links

    # Read CSV file
    with open(input_csv, 'r') as inF:
        reader = csv.DictReader(inF)
        data = list(reader)

    # Determine the appropriate headers based on csv_type
    if csv_type == "csv_summary":
        fraction_key = "fraction"
    elif csv_type == "with-lineages":
        fraction_key = "f_unique_weighted"
    else:
        raise ValueError("Invalid csv_type. Use 'csv_summary' or 'with-lineages'.")

    # Process each row in the dataset
    for row in data:
        fraction = float(row[fraction_key]) * 100  # Convert to percentage
        lineage_parts = row["lineage"].split(";")  # Taxonomic hierarchy

        # Iterate through lineage levels and create source-target links
        for i in range(len(lineage_parts) - 1):
            source_label = lineage_parts[i].strip()
            target_label = lineage_parts[i + 1].strip()

            # Since 'tax metagenome' is already summarized, skip duplicates to prevent overcounting
            if csv_type == "csv_summary" and (source_label, target_label) in processed_lineages:
                continue

            # Assign indices to nodes
            if source_label not in node_map:
                node_map[source_label] = len(nodes)
                nodes.append(source_label)

            if target_label not in node_map:
                node_map[target_label] = len(nodes)
                nodes.append(target_label)

            # Create a link between source and target
            links.append({
                "source": node_map[source_label],
                "target": node_map[target_label],
                "value": fraction
            })
            processed_lineages.add((source_label, target_label))  # Track added links
            hover_texts.append(f"{source_label} â†’ {target_label}<br>{fraction:.2f}%")

    return nodes, links, hover_texts


def main(args):

    # Build info appropriately based on input file type
    if args.summary_csv:
        input_csv = args.summary_csv
        csv_type = "csv_summary"
        required_headers = ["fraction", "lineage"]
    else:
        input_csv = args.annotate_csv
        csv_type = "with-lineages"
        required_headers = ["f_unique_weighted", "lineage"]

    # Check if the required headers are present
    with open(input_csv, 'r') as file:
        reader = csv.DictReader(file)
        if not all(header in reader.fieldnames for header in required_headers):
            raise ValueError(f"Expected headers {required_headers} not found. Is this a correct file for '{csv_type}' type?")

    # process csv
    nodes, links, hover_texts = process_csv(input_csv, csv_type)
    base_title = input_csv.rsplit(".csv")[0]

    # Create Sankey diagram
    fig = go.Figure(go.Sankey(
        node=dict(
            pad=15,
            thickness=20,
            label=nodes
        ),
        link=dict(
            source=[link["source"] for link in links],
            target=[link["target"] for link in links],
            value=[link["value"] for link in links],
            customdata=hover_texts,
            hovertemplate="%{customdata}<extra></extra>"  # Use custom hover text
        )
    ))

    if args.title:
        title = args.title
    else:
        title = base_title 
    fig.update_layout(title_text=f"{title}",
                      font_size=10,
                      autosize=False,
                      width=1500,  # Increase width
                      height=900   # Increase height
                    )

    # Save output based on file extension
    save_sankey_diagram(fig, args.output)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a Sankey diagram from a taxonomy summary CSV file.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--summary-csv", type=str, help="Path to csv_summary generated by running 'sourmash tax metagenome' on a sourmash gather csv")
    group.add_argument("--annotate-csv", type=str, help="Path to 'with-lineages' file generated by running 'sourmash tax annotate' on a sourmash gather csv")
    parser.add_argument("-o", "--output", type=str, help="output file for alluvial flow diagram")
    parser.add_argument("--title", type=str, help="Plot title (default: use input filename)")
    args = parser.parse_args()
    
    main(args)


